plugins {
    id('com.github.jk1.dependency-license-report') version '2.1'
    id "org.kordamp.gradle.markdown" version "2.2.0"
    id("com.github.johnrengelman.shadow") version "8.1.0"
    id("io.micronaut.application") version "3.7.5" apply false
    id("io.micronaut.library") version "3.7.5" apply false
    id 'eclipse'
    id "com.github.ben-manes.versions" version "0.46.0"
    id "org.asciidoctor.jvm.convert" version "3.3.2"
}

group = "com.fortify.cli"

ext {
	buildTime = LocalDateTime.now()
	getVersion = {
    	def result = project.findProperty('version');
    	return !result || result=='unspecified' ? buildTime.format('0.yyyyMMdd.HHmmss') : result;
	}
	distDir = layout.buildDirectory.dir('dist')
	releaseAssetsDir = layout.buildDirectory.dir("dist/release-assets")
}
version = ext.getVersion();

apply plugin: "io.micronaut.application"
subprojects {
    apply plugin: "io.micronaut.library"
    apply plugin: 'eclipse'
}


allprojects {
	// Define Java version
    java {
        sourceCompatibility = JavaVersion.toVersion("17")
        targetCompatibility = JavaVersion.toVersion("17")
    }
    
    // Define Maven Central repository
    repositories {
        mavenCentral()
    }
    
    // Define Micronaut properties
    micronaut {
        testRuntime("junit5")
        processing {
            incremental(true)
            annotations("com.fortify.cli.*")
        }
    }
    
    ext {
    	// Define micronaut dependency versions
    	// TODO Can we use a bom instead of this property
    	micronautVersion = "3.8.7"
    	// Define the top-level fcli command class, used
    	// for generating manual pages, reflect-config.json, ...
    	rootCommandsClassName = "com.fortify.cli.app.FCLIRootCommands"
    }

	// Global dependencies for all modules
    dependencies {
        // Lombok dependency & annotation processor.
        // We also allow Lombok annotations in test classes;
        // for now this is only used by fcli-util.
        compileOnly 'org.projectlombok:lombok:1.18.26'
        annotationProcessor 'org.projectlombok:lombok:1.18.26'
        testCompileOnly 'org.projectlombok:lombok:1.18.26'
        testAnnotationProcessor 'org.projectlombok:lombok:1.18.26'
        
        // TODO Re-enable when removing patched picocli classes from fcli-common
        //implementation("info.picocli:picocli:4.7.1")
        annotationProcessor("info.picocli:picocli-codegen:4.7.1")
        
        implementation("org.fusesource.jansi:jansi:2.4.0");     

        annotationProcessor("io.micronaut:micronaut-inject-java:${micronautVersion}")
        annotationProcessor("io.micronaut:micronaut-graal:${micronautVersion}")

        // Micronaut dependencies
        implementation("io.micronaut:micronaut-runtime:${micronautVersion}")
        implementation("io.micronaut.picocli:micronaut-picocli:4.3.0") {
            exclude group: 'info.picocli'
        }
        implementation("javax.annotation:javax.annotation-api")

        // Logback dependency to allow us to configure logging programmatically
        implementation("ch.qos.logback:logback-classic:1.4.6")

        implementation('com.konghq:unirest-java:3.13.11') {
            exclude group: 'com.google.code.gson', module: 'gson' // We use Jackson, so no need for Gson
            exclude group: 'commons-logging', module: 'commons-logging' // We use jcl-over-slf4j
        }
        implementation('com.konghq:unirest-objectmapper-jackson:3.14.2')
        
        // Support for Spring expression language (SpEL)
        implementation('org.springframework:spring-expression:6.0.7')
        // Support for handling Jackson JsonNode objects with SpEL 
        implementation('org.springframework.integration:spring-integration-core:6.0.3')
        // Remove annotation processor warning
        compileOnly('com.google.code.findbugs:jsr305:3.0.2')

        // for yaml support and generating trees/tables
        implementation('com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.14.2')
        implementation('com.fasterxml.jackson.dataformat:jackson-dataformat-csv:2.14.2')
        implementation("com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.14.2")
        implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.14.2")
        implementation('hu.webarticum:tree-printer:3.1.0')
        implementation('com.github.freva:ascii-table:1.8.0')
        
        // Encryption library
        implementation('org.jasypt:jasypt:1.9.3:lite')
        
        // Test dependencies
        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.2'
        testImplementation 'org.junit.jupiter:junit-jupiter-params:5.9.2'
    	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.2'
    }
    
    compileJava {
    	// Enable verbose logging for picocli annotation processor
    	// The reflect-config.json generated by the picocli annotation processor
    	// is lacking many entries, hence we disable this functionality here and
    	// use a separate generatePicocliReflectConfig task to generate a proper 
    	// reflect-config.json file. 
        options.compilerArgs += ["-Averbose=true","-Adisable.reflect.config=true"]
    }
    
    test {
    	useJUnitPlatform()
    	// Show test output in Gradle output, sometimes easier than opening the
    	// test reports in a browser
	    testLogging {
	        showStandardStreams = true
	    }
	}
    
    // Micronaut is supposed to generate a resource-config.json file that includes all resources,
    // but for some reason this doesn't work, so we generate our own resource-config.json file for
    // each module
    ext.generatedResourceConfigDir = "${buildDir}/generated-resource-config"
    tasks.register('generateResourceConfig') {
        doLast {
            def outputDir = "${generatedResourceConfigDir}/META-INF/native-image/fcli-generated/${project.name}";
            mkdir "${outputDir}"
            def entries = [];
            fileTree(dir: 'src/main/resources', excludes: ['**/i18n/**', 'META-INF/**'])
                .visit {e -> if ( !e.isDirectory() ) {entries << '\n  {"pattern":"'+e.relativePath+'"}'}};
            if ( entries.size>0 ) {
                def contents = '{"resources":[' + entries.join(",") + '\n]}';
                file("${outputDir}/resource-config.json").text = contents;
                println contents
            }
        }
    }
    sourceSets.main.output.dir generatedResourceConfigDir, builtBy: generateResourceConfig
}

// Add fcli-common dependency to all modules except fcli-common itself
configure(allprojects.findAll {it.name != 'fcli-common'}) {
    dependencies {
        implementation project(':fcli-common')
    }
}

// Configure additional dependencies for the root module, amending the 
// dependencies already declared in the allprojects section above.
dependencies {
    implementation project(':fcli-config')
    implementation project(':fcli-state')
    implementation project(':fcli-ssc')
    implementation project(':fcli-fod')
    implementation project(':fcli-sc-sast')
    implementation project(':fcli-sc-dast')
    implementation project(':fcli-tool')
    implementation project(':fcli-util')

    // Logging dependencies
    //runtimeOnly('ch.qos.logback:logback-classic:1.4.6')
    runtimeOnly('org.slf4j:jcl-over-slf4j:2.0.6')

    // GraalVM dependency
    compileOnly("org.graalvm.nativeimage:svm")
}

// Apply shared gradle helpers
ext {
    gradleHelpersLocation = "https://raw.githubusercontent.com/fortify/shared-gradle-helpers/1.8"
    thirdPartyBaseName = "${rootProject.name}"
    autoCompleteDir = "${project.buildDir}/dist"
}
apply from: "${gradleHelpersLocation}/thirdparty-helper.gradle"
apply from: "${gradleHelpersLocation}/readme2html.gradle"

// Generate build properties and associated resource-config.json file
ext.buildPropertiesDir = "${buildDir}/generated-build-properties"
task generateFcliBuildProperties {
    doLast {
        def outputDir = "${buildPropertiesDir}/com/fortify/cli/app"
        mkdir "${outputDir}"
        ant.propertyfile(file: "${outputDir}/fcli-build.properties") {
            entry(key: "projectName", value: project.name)
            entry(key: "projectVersion", value: project.version)
            entry(key: "buildDate", value: buildTime.format('yyyy-MM-dd HH:mm:ss'))
        }
        def resourceConfigOutputDir = "${buildPropertiesDir}/META-INF/native-image/fcli-build-properties"
        mkdir "${resourceConfigOutputDir}"
        def contents = 
        	'{"resources":[\n' +
  			'  {"pattern":"com/fortify/cli/app/fcli-build.properties"}\n' +
			']}\n'
        file("${resourceConfigOutputDir}/resource-config.json").text = contents;
        println contents
    }
}
sourceSets.main.output.dir buildPropertiesDir, builtBy: generateFcliBuildProperties

// Generate reflect-config.json for picocli-related classes
ext.generatedPicocliReflectConfigDir = "${buildDir}/generated-reflect-config"
task generatePicocliReflectConfig(type: JavaExec) {
    group = "GeneratePicocliReflectConfig"
    description = "Generate picocli reflect-config.json"
    classpath(configurations.runtimeClasspath, configurations.annotationProcessor, sourceSets.main.runtimeClasspath)
    main 'picocli.codegen.aot.graalvm.ReflectionConfigGenerator'
    args rootCommandsClassName, "-o", "${generatedPicocliReflectConfigDir}/META-INF/native-image/picocli-reflect-config/reflect-config.json"
}

// Generate shadow jar
application {
    mainClass.set("com.fortify.cli.app.FortifyCLI")
}
shadowJar {
	mergeServiceFiles()
    archiveBaseName.set('fcli')
    archiveClassifier.set('')
    archiveVersion.set('')
    from(["$generatedPicocliReflectConfigDir"])
}
shadowJar.dependsOn generatePicocliReflectConfig

// Generate auto-completion script 
tasks.register('generateAutoCompleteDir') {
    doLast {
        mkdir "${autoCompleteDir}"
    }
}
task distAutoComplete(type: JavaExec) {
    dependsOn(classes, generateAutoCompleteDir)
    group = "Documentation"
    description = "Generate autocomplete"
    classpath(configurations.runtimeClasspath, configurations.annotationProcessor, sourceSets.main.runtimeClasspath)
    main 'picocli.AutoComplete'
    args rootCommandsClassName, "-f", "--completionScript=${autoCompleteDir}/fcli_completion"
}

// Generate manual pages in AsciiDoc format
task generateManpageAsciiDoc(type: JavaExec) {
    dependsOn(classes)
    group = "Documentation"
    description = "Generate AsciiDoc manpage"
    classpath(configurations.runtimeClasspath, configurations.annotationProcessor, sourceSets.main.runtimeClasspath)
    main 'picocli.codegen.docgen.manpage.ManPageGenerator'
    args rootCommandsClassName, "--outdir=${project.buildDir}/generated-docs/src/manpage", "-v"
}


// Generate manpages from AsciiDoc generated by picocli
task asciiDoctorManPage(type: org.asciidoctor.gradle.jvm.AsciidoctorTask) {
	dependsOn(generateManpageAsciiDoc)
	inProcess = JAVA_EXEC
	forkOptions {
        jvmArgs("--add-opens","java.base/sun.nio.ch=ALL-UNNAMED","--add-opens","java.base/java.io=ALL-UNNAMED")
    }
    sourceDir = file("${project.buildDir}/generated-docs/src/manpage")  
    outputDir = file("${project.buildDir}/generated-docs/manpage")
    logDocuments = true
    outputOptions {
        backends = ['manpage']
    }
}

// Copy picocli and versioned AsciiDoc into source directory for HTML generation
task prepareAsciiDocForHtml(type: Copy) {
	dependsOn 'generateManpageAsciiDoc'
	into "${project.buildDir}/generated-docs/src/html"
	from("${projectDir}/doc-resources/asciidoc/versioned") {
        include "*.adoc"
    }
    from("${project.buildDir}/generated-docs/src") {
        include "manpage/*.adoc"
    }
}

// Generate stand-alone HTML documentation from AsciiDoc prepared by prepareAsciiDoc
task asciiDoctorHtml(type: org.asciidoctor.gradle.jvm.AsciidoctorTask) {
    dependsOn(prepareAsciiDocForHtml)
    inProcess = JAVA_EXEC
	forkOptions {
        jvmArgs("--add-opens","java.base/sun.nio.ch=ALL-UNNAMED","--add-opens","java.base/java.io=ALL-UNNAMED")
    }
    sourceDir = file("${project.buildDir}/generated-docs/src/html")
    outputDir = file("${project.buildDir}/generated-docs/html5")
    logDocuments = true
    outputOptions {
        backends = ['html5']
    }
    attributes = [
            'toc'         : 'left',
            'sectanchors' : 'true',
            'docinfo'     : 'shared',
            'jekyll'      : false,
            'bannertitle' : 'FCLI: The Universal Fortify CLI',
            'docversion'  : "${project.version}"
    ]
    options = [
    	'template_dirs': [new File("${project.rootDir}/doc-resources/asciidoc/templates").absolutePath]
    ]
}

// Generate Jekyll HTML documentation from AsciiDoc prepared by prepareAsciiDoc,
// to be deployed to a version-specific directory on the fcli gh-pages site
task asciidoctorJekyll(type: org.asciidoctor.gradle.jvm.AsciidoctorTask) {
	dependsOn(prepareAsciiDocForHtml)
	inProcess = JAVA_EXEC
	forkOptions {
        jvmArgs("--add-opens","java.base/sun.nio.ch=ALL-UNNAMED","--add-opens","java.base/java.io=ALL-UNNAMED")
    }
    sourceDir = file("${project.buildDir}/generated-docs/src/html")
    outputDir = file("${project.buildDir}/generated-docs/jekyll")
    logDocuments = true
    outputOptions {
        backends = ['html5']
    }
    attributes = [
            'toc'         : 'left',
            'sectanchors' : 'true',
            'docinfo'     : 'shared',
            'jekyll'      : true,
            'stylesheet'  : false,
            'bannertitle' : 'FCLI: The Universal Fortify CLI',
            'docversion'  : "${project.version}"
    ]
    options = [
    	'template_dirs': [new File("${project.rootDir}/doc-resources/asciidoc/templates").absolutePath]
    ]
}

// Generate Jekyll HTML documentation from AsciiDoc files in doc-resources/asciidoc/gh-pages, 
// to be deployed to the root directory on the fcli gh-pages site
task asciidoctorGHPages(type: org.asciidoctor.gradle.jvm.AsciidoctorTask) {
	inProcess = JAVA_EXEC
	forkOptions {
        jvmArgs("--add-opens","java.base/sun.nio.ch=ALL-UNNAMED","--add-opens","java.base/java.io=ALL-UNNAMED")
    }
    sourceDir = file("${project.rootDir}/doc-resources/asciidoc/gh-pages")
    outputDir = file("${project.buildDir}/generated-docs/gh-pages")
    logDocuments = true
    outputOptions {
        backends = ['html5']
    }
    attributes = [
            'toc'         : 'left',
            'sectanchors' : 'true',
            'docinfo'     : 'shared',
            'jekyll'      : true,
            'stylesheet'  : false,
            'bannertitle' : 'FCLI: The Universal Fortify CLI',
            'docversion'  : "[select]",
            'revnumber'   : "none"
    ]
    options = [
    	'template_dirs': [new File("${project.rootDir}/doc-resources/asciidoc/templates").absolutePath]
    ]
}

// Zip the output of the asciiDoctorHtml task into ${releaseAssetsDir}
tasks.register('distDocsHtml5', Zip) {
    dependsOn 'asciiDoctorHtml'
    archiveFileName = "docs-html.zip"
    destinationDirectory = releaseAssetsDir
    from layout.buildDirectory.dir("generated-docs/html5")
}

// Zip the output of the asciiDoctorManPage task into ${releaseAssetsDir}
tasks.register('distDocsManPage', Zip) {
    dependsOn 'asciiDoctorManPage'
    archiveFileName = "docs-manpage.zip"
    destinationDirectory = releaseAssetsDir
    from layout.buildDirectory.dir("generated-docs/manpage")
}

// Zip the output of the asciidoctorJekyll task into ${distDir}
// (not using ${releaseAssetsDir}, as we don't want these to be
// published as assets on the GitHub releases page).
tasks.register('distDocsJekyll', Zip) {
    dependsOn 'asciidoctorJekyll'
    archiveFileName = "docs-jekyll.zip"
    destinationDirectory = distDir
    from layout.buildDirectory.dir("generated-docs/jekyll")
}

// Zip the output of the asciidoctorGHPages task into ${distDir}
// (not using ${releaseAssetsDir}, as we don't want these to be
// published as assets on the GitHub releases page).
tasks.register('distDocsGHPages', Zip) {
    dependsOn 'asciidoctorGHPages'
    archiveFileName = "docs-gh-pages.zip"
    destinationDirectory = distDir
    from layout.buildDirectory.dir("generated-docs/gh-pages")
}

// Task to combine all distDocs* tasks
task distDocs {
    dependsOn 'distDocsHtml5', 'distDocsManPage', 'distDocsJekyll', 'distDocsGHPages'
}

// Copy build output (fcli.jar, license, ...) to the ${releaseAssetsDir} directory. 
// Note that the various dist* tasks declared in 'dependsOn' already populate publish
// some artifacts to the dist directory.
task dist(type: Copy) {
    dependsOn 'build', 'readme2html', 'distDocs', 'distAutoComplete'
    from "${buildDir}/html"
    from("${projectDir}") {
        include "LICENSE.txt"
    }
    from("${buildDir}/${libsDirName}") {
        include "${rootProject.name}.jar"
    }
    into releaseAssetsDir
}

task distThirdPartyReleaseAsset {
	dependsOn 'distThirdParty'
	doLast {
		file("$buildDir/dist/fcli-thirdparty.zip").renameTo(file("$buildDir/dist/release-assets/fcli-thirdparty.zip"))
	}
}